Terminals unused in grammar

   COMMENT


State 41 conflicts: 1 reduce/reduce
State 58 conflicts: 5 reduce/reduce
State 80 conflicts: 1 reduce/reduce
State 94 conflicts: 1 reduce/reduce
State 96 conflicts: 1 reduce/reduce
State 105 conflicts: 1 shift/reduce
State 132 conflicts: 1 shift/reduce
State 141 conflicts: 1 shift/reduce
State 142 conflicts: 1 shift/reduce


Grammar

    0 $accept: prog_start $end

    1 prog_start: %empty
    2           | functions

    3 functions: function
    4          | function functions

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    6 args: declaration COMMA args
    7     | declaration
    8     | %empty

    9 statements: statement SEMICOLON
   10           | statement SEMICOLON statements
   11           | %empty

   12 statement: declaration
   13          | function_call
   14          | num
   15          | if
   16          | while
   17          | for
   18          | input
   19          | output
   20          | return
   21          | ID L_BRACKET NUMBER R_BRACKET ASSIGN exp
   22          | ID ASSIGN exp
   23          | ID ASSIGN function_call

   24 return: RETURN ID
   25       | RETURN exp

   26 num: NUM ID ASSIGN exp
   27    | NUM ID ASSIGN NUMBER
   28    | NUM ID ASSIGN function_call

   29 if: IF bool_exp L_C_BRACKET statements R_C_BRACKET
   30   | IF bool_exp L_C_BRACKET statements elsify R_C_BRACKET
   31   | IF bool_exp L_C_BRACKET statements BREAK SEMICOLON R_C_BRACKET
   32   | IF bool_exp L_C_BRACKET statements BREAK SEMICOLON elsify R_C_BRACKET
   33   | IF bool_exp L_C_BRACKET statements CONTINUE SEMICOLON R_C_BRACKET
   34   | IF bool_exp L_C_BRACKET statements CONTINUE SEMICOLON elsify R_C_BRACKET

   35 elsify: elif elsify
   36       | else
   37       | %empty

   38 elif: ELIF bool_exp L_C_BRACKET statements R_C_BRACKET

   39 else: ELSE L_C_BRACKET statements R_C_BRACKET

   40 while: WHILE bool_exp L_C_BRACKET statements R_C_BRACKET

   41 for: FOR num SEMICOLON bool_exp ID ASSIGN exp L_C_BRACKET statements R_C_BRACKET

   42 input: INPUT L_PAREN ID R_PAREN
   43      | INPUT L_PAREN ID L_BRACKET NUMBER R_BRACKET R_PAREN

   44 output: OUTPUT L_PAREN exp R_PAREN
   45       | OUTPUT L_PAREN ID L_BRACKET NUMBER R_BRACKET R_PAREN

   46 exp: exp PLUS term
   47    | exp MINUS term
   48    | term

   49 bool_exp: L_PAREN exp GREATER exp R_PAREN
   50         | L_PAREN exp LESS exp R_PAREN
   51         | L_PAREN exp EQUAL exp R_PAREN
   52         | L_PAREN exp LE_EQ exp R_PAREN
   53         | L_PAREN exp GE_EQ exp R_PAREN
   54         | L_PAREN exp NOT_EQUAL exp R_PAREN
   55         | L_PAREN exp R_PAREN

   56 term: term MULTI factor
   57     | term DIVISION factor
   58     | term MOD factor
   59     | factor

   60 factor: L_PAREN exp R_PAREN
   61       | NUMBER
   62       | ID
   63       | function_call
   64       | ID L_BRACKET NUMBER R_BRACKET

   65 declaration: NUM ID L_BRACKET NUMBER R_BRACKET
   66            | NUM ID

   67 parameters: exp
   68           | exp COMMA parameters
   69           | %empty

   70 function_call: ID L_PAREN parameters R_PAREN


Terminals, with rules where they appear

$end (0) 0
error (256)
MOD (258) 58
RETURN (259) 24 25
INPUT (260) 42 43
OUTPUT (261) 44 45
NUMBER (262) 21 27 43 45 61 64 65
NUM (263) 26 27 28 65 66
WHILE (264) 40
IF (265) 29 30 31 32 33 34
ELIF (266) 38
ELSE (267) 39
FUNC (268) 5
PLUS (269) 46
MINUS (270) 47
MULTI (271) 56
DIVISION (272) 57
LESS (273) 50
GREATER (274) 49
EQUAL (275) 51
NOT_EQUAL (276) 54
LE_EQ (277) 52
GE_EQ (278) 53
COMMENT (279)
L_BRACKET (280) 21 43 45 64 65
R_BRACKET (281) 21 43 45 64 65
L_C_BRACKET (282) 5 29 30 31 32 33 34 38 39 40 41
R_C_BRACKET (283) 5 29 30 31 32 33 34 38 39 40 41
L_PAREN (284) 5 42 43 44 45 49 50 51 52 53 54 55 60 70
R_PAREN (285) 5 42 43 44 45 49 50 51 52 53 54 55 60 70
ASSIGN (286) 21 22 23 26 27 28 41
SEMICOLON (287) 5 9 10 31 32 33 34 41
COMMA (288) 6 68
FOR (289) 41
BREAK (290) 31 32
CONTINUE (291) 33 34
ID (292) 5 21 22 23 24 26 27 28 41 42 43 45 62 64 65 66 70


Nonterminals, with rules where they appear

$accept (38)
    on left: 0
prog_start (39)
    on left: 1 2, on right: 0
functions (40)
    on left: 3 4, on right: 2 4
function (41)
    on left: 5, on right: 3 4
args (42)
    on left: 6 7 8, on right: 5 6
statements (43)
    on left: 9 10 11, on right: 5 10 29 30 31 32 33 34 38 39 40 41
statement (44)
    on left: 12 13 14 15 16 17 18 19 20 21 22 23, on right: 9 10
return (45)
    on left: 24 25, on right: 20
num (46)
    on left: 26 27 28, on right: 14 41
if (47)
    on left: 29 30 31 32 33 34, on right: 15
elsify (48)
    on left: 35 36 37, on right: 30 32 34 35
elif (49)
    on left: 38, on right: 35
else (50)
    on left: 39, on right: 36
while (51)
    on left: 40, on right: 16
for (52)
    on left: 41, on right: 17
input (53)
    on left: 42 43, on right: 18
output (54)
    on left: 44 45, on right: 19
exp (55)
    on left: 46 47 48, on right: 21 22 25 26 41 44 46 47 49 50 51 52
    53 54 55 60 67 68
bool_exp (56)
    on left: 49 50 51 52 53 54 55, on right: 29 30 31 32 33 34 38 40
    41
term (57)
    on left: 56 57 58 59, on right: 46 47 48 56 57 58
factor (58)
    on left: 60 61 62 63 64, on right: 56 57 58 59
declaration (59)
    on left: 65 66, on right: 6 7 12
parameters (60)
    on left: 67 68 69, on right: 68 70
function_call (61)
    on left: 70, on right: 13 23 28 63


State 0

    0 $accept: . prog_start $end

    FUNC  shift, and go to state 1

    $default  reduce using rule 1 (prog_start)

    prog_start  go to state 2
    functions   go to state 3
    function    go to state 4


State 1

    5 function: FUNC . ID L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    ID  shift, and go to state 5


State 2

    0 $accept: prog_start . $end

    $end  shift, and go to state 6


State 3

    2 prog_start: functions .

    $default  reduce using rule 2 (prog_start)


State 4

    3 functions: function .
    4          | function . functions

    FUNC  shift, and go to state 1

    $default  reduce using rule 3 (functions)

    functions  go to state 7
    function   go to state 4


State 5

    5 function: FUNC ID . L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    L_PAREN  shift, and go to state 8


State 6

    0 $accept: prog_start $end .

    $default  accept


State 7

    4 functions: function functions .

    $default  reduce using rule 4 (functions)


State 8

    5 function: FUNC ID L_PAREN . args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    NUM  shift, and go to state 9

    $default  reduce using rule 8 (args)

    args         go to state 10
    declaration  go to state 11


State 9

   65 declaration: NUM . ID L_BRACKET NUMBER R_BRACKET
   66            | NUM . ID

    ID  shift, and go to state 12


State 10

    5 function: FUNC ID L_PAREN args . R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    R_PAREN  shift, and go to state 13


State 11

    6 args: declaration . COMMA args
    7     | declaration .

    COMMA  shift, and go to state 14

    $default  reduce using rule 7 (args)


State 12

   65 declaration: NUM ID . L_BRACKET NUMBER R_BRACKET
   66            | NUM ID .

    L_BRACKET  shift, and go to state 15

    $default  reduce using rule 66 (declaration)


State 13

    5 function: FUNC ID L_PAREN args R_PAREN . L_C_BRACKET statements R_C_BRACKET SEMICOLON

    L_C_BRACKET  shift, and go to state 16


State 14

    6 args: declaration COMMA . args

    NUM  shift, and go to state 9

    $default  reduce using rule 8 (args)

    args         go to state 17
    declaration  go to state 11


State 15

   65 declaration: NUM ID L_BRACKET . NUMBER R_BRACKET

    NUMBER  shift, and go to state 18


State 16

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET . statements R_C_BRACKET SEMICOLON

    RETURN  shift, and go to state 19
    INPUT   shift, and go to state 20
    OUTPUT  shift, and go to state 21
    NUM     shift, and go to state 22
    WHILE   shift, and go to state 23
    IF      shift, and go to state 24
    FOR     shift, and go to state 25
    ID      shift, and go to state 26

    $default  reduce using rule 11 (statements)

    statements     go to state 27
    statement      go to state 28
    return         go to state 29
    num            go to state 30
    if             go to state 31
    while          go to state 32
    for            go to state 33
    input          go to state 34
    output         go to state 35
    declaration    go to state 36
    function_call  go to state 37


State 17

    6 args: declaration COMMA args .

    $default  reduce using rule 6 (args)


State 18

   65 declaration: NUM ID L_BRACKET NUMBER . R_BRACKET

    R_BRACKET  shift, and go to state 38


State 19

   24 return: RETURN . ID
   25       | RETURN . exp

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 41

    exp            go to state 42
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 20

   42 input: INPUT . L_PAREN ID R_PAREN
   43      | INPUT . L_PAREN ID L_BRACKET NUMBER R_BRACKET R_PAREN

    L_PAREN  shift, and go to state 46


State 21

   44 output: OUTPUT . L_PAREN exp R_PAREN
   45       | OUTPUT . L_PAREN ID L_BRACKET NUMBER R_BRACKET R_PAREN

    L_PAREN  shift, and go to state 47


State 22

   26 num: NUM . ID ASSIGN exp
   27    | NUM . ID ASSIGN NUMBER
   28    | NUM . ID ASSIGN function_call
   65 declaration: NUM . ID L_BRACKET NUMBER R_BRACKET
   66            | NUM . ID

    ID  shift, and go to state 48


State 23

   40 while: WHILE . bool_exp L_C_BRACKET statements R_C_BRACKET

    L_PAREN  shift, and go to state 49

    bool_exp  go to state 50


State 24

   29 if: IF . bool_exp L_C_BRACKET statements R_C_BRACKET
   30   | IF . bool_exp L_C_BRACKET statements elsify R_C_BRACKET
   31   | IF . bool_exp L_C_BRACKET statements BREAK SEMICOLON R_C_BRACKET
   32   | IF . bool_exp L_C_BRACKET statements BREAK SEMICOLON elsify R_C_BRACKET
   33   | IF . bool_exp L_C_BRACKET statements CONTINUE SEMICOLON R_C_BRACKET
   34   | IF . bool_exp L_C_BRACKET statements CONTINUE SEMICOLON elsify R_C_BRACKET

    L_PAREN  shift, and go to state 49

    bool_exp  go to state 51


State 25

   41 for: FOR . num SEMICOLON bool_exp ID ASSIGN exp L_C_BRACKET statements R_C_BRACKET

    NUM  shift, and go to state 52

    num  go to state 53


State 26

   21 statement: ID . L_BRACKET NUMBER R_BRACKET ASSIGN exp
   22          | ID . ASSIGN exp
   23          | ID . ASSIGN function_call
   70 function_call: ID . L_PAREN parameters R_PAREN

    L_BRACKET  shift, and go to state 54
    L_PAREN    shift, and go to state 55
    ASSIGN     shift, and go to state 56


State 27

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET statements . R_C_BRACKET SEMICOLON

    R_C_BRACKET  shift, and go to state 57


State 28

    9 statements: statement . SEMICOLON
   10           | statement . SEMICOLON statements

    SEMICOLON  shift, and go to state 58


State 29

   20 statement: return .

    $default  reduce using rule 20 (statement)


State 30

   14 statement: num .

    $default  reduce using rule 14 (statement)


State 31

   15 statement: if .

    $default  reduce using rule 15 (statement)


State 32

   16 statement: while .

    $default  reduce using rule 16 (statement)


State 33

   17 statement: for .

    $default  reduce using rule 17 (statement)


State 34

   18 statement: input .

    $default  reduce using rule 18 (statement)


State 35

   19 statement: output .

    $default  reduce using rule 19 (statement)


State 36

   12 statement: declaration .

    $default  reduce using rule 12 (statement)


State 37

   13 statement: function_call .

    $default  reduce using rule 13 (statement)


State 38

   65 declaration: NUM ID L_BRACKET NUMBER R_BRACKET .

    $default  reduce using rule 65 (declaration)


State 39

   61 factor: NUMBER .

    $default  reduce using rule 61 (factor)


State 40

   60 factor: L_PAREN . exp R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 60
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 41

   24 return: RETURN ID .
   62 factor: ID .
   64       | ID . L_BRACKET NUMBER R_BRACKET
   70 function_call: ID . L_PAREN parameters R_PAREN

    L_BRACKET  shift, and go to state 61
    L_PAREN    shift, and go to state 55

    SEMICOLON  reduce using rule 24 (return)
    SEMICOLON  [reduce using rule 62 (factor)]
    $default   reduce using rule 62 (factor)


State 42

   25 return: RETURN exp .
   46 exp: exp . PLUS term
   47    | exp . MINUS term

    PLUS   shift, and go to state 62
    MINUS  shift, and go to state 63

    $default  reduce using rule 25 (return)


State 43

   48 exp: term .
   56 term: term . MULTI factor
   57     | term . DIVISION factor
   58     | term . MOD factor

    MOD       shift, and go to state 64
    MULTI     shift, and go to state 65
    DIVISION  shift, and go to state 66

    $default  reduce using rule 48 (exp)


State 44

   59 term: factor .

    $default  reduce using rule 59 (term)


State 45

   63 factor: function_call .

    $default  reduce using rule 63 (factor)


State 46

   42 input: INPUT L_PAREN . ID R_PAREN
   43      | INPUT L_PAREN . ID L_BRACKET NUMBER R_BRACKET R_PAREN

    ID  shift, and go to state 67


State 47

   44 output: OUTPUT L_PAREN . exp R_PAREN
   45       | OUTPUT L_PAREN . ID L_BRACKET NUMBER R_BRACKET R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 68

    exp            go to state 69
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 48

   26 num: NUM ID . ASSIGN exp
   27    | NUM ID . ASSIGN NUMBER
   28    | NUM ID . ASSIGN function_call
   65 declaration: NUM ID . L_BRACKET NUMBER R_BRACKET
   66            | NUM ID .

    L_BRACKET  shift, and go to state 15
    ASSIGN     shift, and go to state 70

    $default  reduce using rule 66 (declaration)


State 49

   49 bool_exp: L_PAREN . exp GREATER exp R_PAREN
   50         | L_PAREN . exp LESS exp R_PAREN
   51         | L_PAREN . exp EQUAL exp R_PAREN
   52         | L_PAREN . exp LE_EQ exp R_PAREN
   53         | L_PAREN . exp GE_EQ exp R_PAREN
   54         | L_PAREN . exp NOT_EQUAL exp R_PAREN
   55         | L_PAREN . exp R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 71
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 50

   40 while: WHILE bool_exp . L_C_BRACKET statements R_C_BRACKET

    L_C_BRACKET  shift, and go to state 72


State 51

   29 if: IF bool_exp . L_C_BRACKET statements R_C_BRACKET
   30   | IF bool_exp . L_C_BRACKET statements elsify R_C_BRACKET
   31   | IF bool_exp . L_C_BRACKET statements BREAK SEMICOLON R_C_BRACKET
   32   | IF bool_exp . L_C_BRACKET statements BREAK SEMICOLON elsify R_C_BRACKET
   33   | IF bool_exp . L_C_BRACKET statements CONTINUE SEMICOLON R_C_BRACKET
   34   | IF bool_exp . L_C_BRACKET statements CONTINUE SEMICOLON elsify R_C_BRACKET

    L_C_BRACKET  shift, and go to state 73


State 52

   26 num: NUM . ID ASSIGN exp
   27    | NUM . ID ASSIGN NUMBER
   28    | NUM . ID ASSIGN function_call

    ID  shift, and go to state 74


State 53

   41 for: FOR num . SEMICOLON bool_exp ID ASSIGN exp L_C_BRACKET statements R_C_BRACKET

    SEMICOLON  shift, and go to state 75


State 54

   21 statement: ID L_BRACKET . NUMBER R_BRACKET ASSIGN exp

    NUMBER  shift, and go to state 76


State 55

   70 function_call: ID L_PAREN . parameters R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    $default  reduce using rule 69 (parameters)

    exp            go to state 77
    term           go to state 43
    factor         go to state 44
    parameters     go to state 78
    function_call  go to state 45


State 56

   22 statement: ID ASSIGN . exp
   23          | ID ASSIGN . function_call

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 79
    term           go to state 43
    factor         go to state 44
    function_call  go to state 80


State 57

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET . SEMICOLON

    SEMICOLON  shift, and go to state 81


State 58

    9 statements: statement SEMICOLON .
   10           | statement SEMICOLON . statements

    RETURN  shift, and go to state 19
    INPUT   shift, and go to state 20
    OUTPUT  shift, and go to state 21
    NUM     shift, and go to state 22
    WHILE   shift, and go to state 23
    IF      shift, and go to state 24
    FOR     shift, and go to state 25
    ID      shift, and go to state 26

    ELIF         reduce using rule 9 (statements)
    ELIF         [reduce using rule 11 (statements)]
    ELSE         reduce using rule 9 (statements)
    ELSE         [reduce using rule 11 (statements)]
    R_C_BRACKET  reduce using rule 9 (statements)
    R_C_BRACKET  [reduce using rule 11 (statements)]
    BREAK        reduce using rule 9 (statements)
    BREAK        [reduce using rule 11 (statements)]
    CONTINUE     reduce using rule 9 (statements)
    CONTINUE     [reduce using rule 11 (statements)]
    $default     reduce using rule 9 (statements)

    statements     go to state 82
    statement      go to state 28
    return         go to state 29
    num            go to state 30
    if             go to state 31
    while          go to state 32
    for            go to state 33
    input          go to state 34
    output         go to state 35
    declaration    go to state 36
    function_call  go to state 37


State 59

   62 factor: ID .
   64       | ID . L_BRACKET NUMBER R_BRACKET
   70 function_call: ID . L_PAREN parameters R_PAREN

    L_BRACKET  shift, and go to state 61
    L_PAREN    shift, and go to state 55

    $default  reduce using rule 62 (factor)


State 60

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   60 factor: L_PAREN exp . R_PAREN

    PLUS     shift, and go to state 62
    MINUS    shift, and go to state 63
    R_PAREN  shift, and go to state 83


State 61

   64 factor: ID L_BRACKET . NUMBER R_BRACKET

    NUMBER  shift, and go to state 84


State 62

   46 exp: exp PLUS . term

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    term           go to state 85
    factor         go to state 44
    function_call  go to state 45


State 63

   47 exp: exp MINUS . term

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    term           go to state 86
    factor         go to state 44
    function_call  go to state 45


State 64

   58 term: term MOD . factor

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    factor         go to state 87
    function_call  go to state 45


State 65

   56 term: term MULTI . factor

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    factor         go to state 88
    function_call  go to state 45


State 66

   57 term: term DIVISION . factor

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    factor         go to state 89
    function_call  go to state 45


State 67

   42 input: INPUT L_PAREN ID . R_PAREN
   43      | INPUT L_PAREN ID . L_BRACKET NUMBER R_BRACKET R_PAREN

    L_BRACKET  shift, and go to state 90
    R_PAREN    shift, and go to state 91


State 68

   45 output: OUTPUT L_PAREN ID . L_BRACKET NUMBER R_BRACKET R_PAREN
   62 factor: ID .
   64       | ID . L_BRACKET NUMBER R_BRACKET
   70 function_call: ID . L_PAREN parameters R_PAREN

    L_BRACKET  shift, and go to state 92
    L_PAREN    shift, and go to state 55

    $default  reduce using rule 62 (factor)


State 69

   44 output: OUTPUT L_PAREN exp . R_PAREN
   46 exp: exp . PLUS term
   47    | exp . MINUS term

    PLUS     shift, and go to state 62
    MINUS    shift, and go to state 63
    R_PAREN  shift, and go to state 93


State 70

   26 num: NUM ID ASSIGN . exp
   27    | NUM ID ASSIGN . NUMBER
   28    | NUM ID ASSIGN . function_call

    NUMBER   shift, and go to state 94
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 95
    term           go to state 43
    factor         go to state 44
    function_call  go to state 96


State 71

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   49 bool_exp: L_PAREN exp . GREATER exp R_PAREN
   50         | L_PAREN exp . LESS exp R_PAREN
   51         | L_PAREN exp . EQUAL exp R_PAREN
   52         | L_PAREN exp . LE_EQ exp R_PAREN
   53         | L_PAREN exp . GE_EQ exp R_PAREN
   54         | L_PAREN exp . NOT_EQUAL exp R_PAREN
   55         | L_PAREN exp . R_PAREN

    PLUS       shift, and go to state 62
    MINUS      shift, and go to state 63
    LESS       shift, and go to state 97
    GREATER    shift, and go to state 98
    EQUAL      shift, and go to state 99
    NOT_EQUAL  shift, and go to state 100
    LE_EQ      shift, and go to state 101
    GE_EQ      shift, and go to state 102
    R_PAREN    shift, and go to state 103


State 72

   40 while: WHILE bool_exp L_C_BRACKET . statements R_C_BRACKET

    RETURN  shift, and go to state 19
    INPUT   shift, and go to state 20
    OUTPUT  shift, and go to state 21
    NUM     shift, and go to state 22
    WHILE   shift, and go to state 23
    IF      shift, and go to state 24
    FOR     shift, and go to state 25
    ID      shift, and go to state 26

    $default  reduce using rule 11 (statements)

    statements     go to state 104
    statement      go to state 28
    return         go to state 29
    num            go to state 30
    if             go to state 31
    while          go to state 32
    for            go to state 33
    input          go to state 34
    output         go to state 35
    declaration    go to state 36
    function_call  go to state 37


State 73

   29 if: IF bool_exp L_C_BRACKET . statements R_C_BRACKET
   30   | IF bool_exp L_C_BRACKET . statements elsify R_C_BRACKET
   31   | IF bool_exp L_C_BRACKET . statements BREAK SEMICOLON R_C_BRACKET
   32   | IF bool_exp L_C_BRACKET . statements BREAK SEMICOLON elsify R_C_BRACKET
   33   | IF bool_exp L_C_BRACKET . statements CONTINUE SEMICOLON R_C_BRACKET
   34   | IF bool_exp L_C_BRACKET . statements CONTINUE SEMICOLON elsify R_C_BRACKET

    RETURN  shift, and go to state 19
    INPUT   shift, and go to state 20
    OUTPUT  shift, and go to state 21
    NUM     shift, and go to state 22
    WHILE   shift, and go to state 23
    IF      shift, and go to state 24
    FOR     shift, and go to state 25
    ID      shift, and go to state 26

    $default  reduce using rule 11 (statements)

    statements     go to state 105
    statement      go to state 28
    return         go to state 29
    num            go to state 30
    if             go to state 31
    while          go to state 32
    for            go to state 33
    input          go to state 34
    output         go to state 35
    declaration    go to state 36
    function_call  go to state 37


State 74

   26 num: NUM ID . ASSIGN exp
   27    | NUM ID . ASSIGN NUMBER
   28    | NUM ID . ASSIGN function_call

    ASSIGN  shift, and go to state 70


State 75

   41 for: FOR num SEMICOLON . bool_exp ID ASSIGN exp L_C_BRACKET statements R_C_BRACKET

    L_PAREN  shift, and go to state 49

    bool_exp  go to state 106


State 76

   21 statement: ID L_BRACKET NUMBER . R_BRACKET ASSIGN exp

    R_BRACKET  shift, and go to state 107


State 77

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   67 parameters: exp .
   68           | exp . COMMA parameters

    PLUS   shift, and go to state 62
    MINUS  shift, and go to state 63
    COMMA  shift, and go to state 108

    $default  reduce using rule 67 (parameters)


State 78

   70 function_call: ID L_PAREN parameters . R_PAREN

    R_PAREN  shift, and go to state 109


State 79

   22 statement: ID ASSIGN exp .
   46 exp: exp . PLUS term
   47    | exp . MINUS term

    PLUS   shift, and go to state 62
    MINUS  shift, and go to state 63

    $default  reduce using rule 22 (statement)


State 80

   23 statement: ID ASSIGN function_call .
   63 factor: function_call .

    SEMICOLON  reduce using rule 23 (statement)
    SEMICOLON  [reduce using rule 63 (factor)]
    $default   reduce using rule 63 (factor)


State 81

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON .

    $default  reduce using rule 5 (function)


State 82

   10 statements: statement SEMICOLON statements .

    $default  reduce using rule 10 (statements)


State 83

   60 factor: L_PAREN exp R_PAREN .

    $default  reduce using rule 60 (factor)


State 84

   64 factor: ID L_BRACKET NUMBER . R_BRACKET

    R_BRACKET  shift, and go to state 110


State 85

   46 exp: exp PLUS term .
   56 term: term . MULTI factor
   57     | term . DIVISION factor
   58     | term . MOD factor

    MOD       shift, and go to state 64
    MULTI     shift, and go to state 65
    DIVISION  shift, and go to state 66

    $default  reduce using rule 46 (exp)


State 86

   47 exp: exp MINUS term .
   56 term: term . MULTI factor
   57     | term . DIVISION factor
   58     | term . MOD factor

    MOD       shift, and go to state 64
    MULTI     shift, and go to state 65
    DIVISION  shift, and go to state 66

    $default  reduce using rule 47 (exp)


State 87

   58 term: term MOD factor .

    $default  reduce using rule 58 (term)


State 88

   56 term: term MULTI factor .

    $default  reduce using rule 56 (term)


State 89

   57 term: term DIVISION factor .

    $default  reduce using rule 57 (term)


State 90

   43 input: INPUT L_PAREN ID L_BRACKET . NUMBER R_BRACKET R_PAREN

    NUMBER  shift, and go to state 111


State 91

   42 input: INPUT L_PAREN ID R_PAREN .

    $default  reduce using rule 42 (input)


State 92

   45 output: OUTPUT L_PAREN ID L_BRACKET . NUMBER R_BRACKET R_PAREN
   64 factor: ID L_BRACKET . NUMBER R_BRACKET

    NUMBER  shift, and go to state 112


State 93

   44 output: OUTPUT L_PAREN exp R_PAREN .

    $default  reduce using rule 44 (output)


State 94

   27 num: NUM ID ASSIGN NUMBER .
   61 factor: NUMBER .

    SEMICOLON  reduce using rule 27 (num)
    SEMICOLON  [reduce using rule 61 (factor)]
    $default   reduce using rule 61 (factor)


State 95

   26 num: NUM ID ASSIGN exp .
   46 exp: exp . PLUS term
   47    | exp . MINUS term

    PLUS   shift, and go to state 62
    MINUS  shift, and go to state 63

    $default  reduce using rule 26 (num)


State 96

   28 num: NUM ID ASSIGN function_call .
   63 factor: function_call .

    SEMICOLON  reduce using rule 28 (num)
    SEMICOLON  [reduce using rule 63 (factor)]
    $default   reduce using rule 63 (factor)


State 97

   50 bool_exp: L_PAREN exp LESS . exp R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 113
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 98

   49 bool_exp: L_PAREN exp GREATER . exp R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 114
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 99

   51 bool_exp: L_PAREN exp EQUAL . exp R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 115
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 100

   54 bool_exp: L_PAREN exp NOT_EQUAL . exp R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 116
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 101

   52 bool_exp: L_PAREN exp LE_EQ . exp R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 117
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 102

   53 bool_exp: L_PAREN exp GE_EQ . exp R_PAREN

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 118
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 103

   55 bool_exp: L_PAREN exp R_PAREN .

    $default  reduce using rule 55 (bool_exp)


State 104

   40 while: WHILE bool_exp L_C_BRACKET statements . R_C_BRACKET

    R_C_BRACKET  shift, and go to state 119


State 105

   29 if: IF bool_exp L_C_BRACKET statements . R_C_BRACKET
   30   | IF bool_exp L_C_BRACKET statements . elsify R_C_BRACKET
   31   | IF bool_exp L_C_BRACKET statements . BREAK SEMICOLON R_C_BRACKET
   32   | IF bool_exp L_C_BRACKET statements . BREAK SEMICOLON elsify R_C_BRACKET
   33   | IF bool_exp L_C_BRACKET statements . CONTINUE SEMICOLON R_C_BRACKET
   34   | IF bool_exp L_C_BRACKET statements . CONTINUE SEMICOLON elsify R_C_BRACKET

    ELIF         shift, and go to state 120
    ELSE         shift, and go to state 121
    R_C_BRACKET  shift, and go to state 122
    BREAK        shift, and go to state 123
    CONTINUE     shift, and go to state 124

    R_C_BRACKET  [reduce using rule 37 (elsify)]

    elsify  go to state 125
    elif    go to state 126
    else    go to state 127


State 106

   41 for: FOR num SEMICOLON bool_exp . ID ASSIGN exp L_C_BRACKET statements R_C_BRACKET

    ID  shift, and go to state 128


State 107

   21 statement: ID L_BRACKET NUMBER R_BRACKET . ASSIGN exp

    ASSIGN  shift, and go to state 129


State 108

   68 parameters: exp COMMA . parameters

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    $default  reduce using rule 69 (parameters)

    exp            go to state 77
    term           go to state 43
    factor         go to state 44
    parameters     go to state 130
    function_call  go to state 45


State 109

   70 function_call: ID L_PAREN parameters R_PAREN .

    $default  reduce using rule 70 (function_call)


State 110

   64 factor: ID L_BRACKET NUMBER R_BRACKET .

    $default  reduce using rule 64 (factor)


State 111

   43 input: INPUT L_PAREN ID L_BRACKET NUMBER . R_BRACKET R_PAREN

    R_BRACKET  shift, and go to state 131


State 112

   45 output: OUTPUT L_PAREN ID L_BRACKET NUMBER . R_BRACKET R_PAREN
   64 factor: ID L_BRACKET NUMBER . R_BRACKET

    R_BRACKET  shift, and go to state 132


State 113

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   50 bool_exp: L_PAREN exp LESS exp . R_PAREN

    PLUS     shift, and go to state 62
    MINUS    shift, and go to state 63
    R_PAREN  shift, and go to state 133


State 114

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   49 bool_exp: L_PAREN exp GREATER exp . R_PAREN

    PLUS     shift, and go to state 62
    MINUS    shift, and go to state 63
    R_PAREN  shift, and go to state 134


State 115

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   51 bool_exp: L_PAREN exp EQUAL exp . R_PAREN

    PLUS     shift, and go to state 62
    MINUS    shift, and go to state 63
    R_PAREN  shift, and go to state 135


State 116

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   54 bool_exp: L_PAREN exp NOT_EQUAL exp . R_PAREN

    PLUS     shift, and go to state 62
    MINUS    shift, and go to state 63
    R_PAREN  shift, and go to state 136


State 117

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   52 bool_exp: L_PAREN exp LE_EQ exp . R_PAREN

    PLUS     shift, and go to state 62
    MINUS    shift, and go to state 63
    R_PAREN  shift, and go to state 137


State 118

   46 exp: exp . PLUS term
   47    | exp . MINUS term
   53 bool_exp: L_PAREN exp GE_EQ exp . R_PAREN

    PLUS     shift, and go to state 62
    MINUS    shift, and go to state 63
    R_PAREN  shift, and go to state 138


State 119

   40 while: WHILE bool_exp L_C_BRACKET statements R_C_BRACKET .

    $default  reduce using rule 40 (while)


State 120

   38 elif: ELIF . bool_exp L_C_BRACKET statements R_C_BRACKET

    L_PAREN  shift, and go to state 49

    bool_exp  go to state 139


State 121

   39 else: ELSE . L_C_BRACKET statements R_C_BRACKET

    L_C_BRACKET  shift, and go to state 140


State 122

   29 if: IF bool_exp L_C_BRACKET statements R_C_BRACKET .

    $default  reduce using rule 29 (if)


State 123

   31 if: IF bool_exp L_C_BRACKET statements BREAK . SEMICOLON R_C_BRACKET
   32   | IF bool_exp L_C_BRACKET statements BREAK . SEMICOLON elsify R_C_BRACKET

    SEMICOLON  shift, and go to state 141


State 124

   33 if: IF bool_exp L_C_BRACKET statements CONTINUE . SEMICOLON R_C_BRACKET
   34   | IF bool_exp L_C_BRACKET statements CONTINUE . SEMICOLON elsify R_C_BRACKET

    SEMICOLON  shift, and go to state 142


State 125

   30 if: IF bool_exp L_C_BRACKET statements elsify . R_C_BRACKET

    R_C_BRACKET  shift, and go to state 143


State 126

   35 elsify: elif . elsify

    ELIF  shift, and go to state 120
    ELSE  shift, and go to state 121

    $default  reduce using rule 37 (elsify)

    elsify  go to state 144
    elif    go to state 126
    else    go to state 127


State 127

   36 elsify: else .

    $default  reduce using rule 36 (elsify)


State 128

   41 for: FOR num SEMICOLON bool_exp ID . ASSIGN exp L_C_BRACKET statements R_C_BRACKET

    ASSIGN  shift, and go to state 145


State 129

   21 statement: ID L_BRACKET NUMBER R_BRACKET ASSIGN . exp

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 146
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 130

   68 parameters: exp COMMA parameters .

    $default  reduce using rule 68 (parameters)


State 131

   43 input: INPUT L_PAREN ID L_BRACKET NUMBER R_BRACKET . R_PAREN

    R_PAREN  shift, and go to state 147


State 132

   45 output: OUTPUT L_PAREN ID L_BRACKET NUMBER R_BRACKET . R_PAREN
   64 factor: ID L_BRACKET NUMBER R_BRACKET .

    R_PAREN  shift, and go to state 148

    R_PAREN   [reduce using rule 64 (factor)]
    $default  reduce using rule 64 (factor)


State 133

   50 bool_exp: L_PAREN exp LESS exp R_PAREN .

    $default  reduce using rule 50 (bool_exp)


State 134

   49 bool_exp: L_PAREN exp GREATER exp R_PAREN .

    $default  reduce using rule 49 (bool_exp)


State 135

   51 bool_exp: L_PAREN exp EQUAL exp R_PAREN .

    $default  reduce using rule 51 (bool_exp)


State 136

   54 bool_exp: L_PAREN exp NOT_EQUAL exp R_PAREN .

    $default  reduce using rule 54 (bool_exp)


State 137

   52 bool_exp: L_PAREN exp LE_EQ exp R_PAREN .

    $default  reduce using rule 52 (bool_exp)


State 138

   53 bool_exp: L_PAREN exp GE_EQ exp R_PAREN .

    $default  reduce using rule 53 (bool_exp)


State 139

   38 elif: ELIF bool_exp . L_C_BRACKET statements R_C_BRACKET

    L_C_BRACKET  shift, and go to state 149


State 140

   39 else: ELSE L_C_BRACKET . statements R_C_BRACKET

    RETURN  shift, and go to state 19
    INPUT   shift, and go to state 20
    OUTPUT  shift, and go to state 21
    NUM     shift, and go to state 22
    WHILE   shift, and go to state 23
    IF      shift, and go to state 24
    FOR     shift, and go to state 25
    ID      shift, and go to state 26

    $default  reduce using rule 11 (statements)

    statements     go to state 150
    statement      go to state 28
    return         go to state 29
    num            go to state 30
    if             go to state 31
    while          go to state 32
    for            go to state 33
    input          go to state 34
    output         go to state 35
    declaration    go to state 36
    function_call  go to state 37


State 141

   31 if: IF bool_exp L_C_BRACKET statements BREAK SEMICOLON . R_C_BRACKET
   32   | IF bool_exp L_C_BRACKET statements BREAK SEMICOLON . elsify R_C_BRACKET

    ELIF         shift, and go to state 120
    ELSE         shift, and go to state 121
    R_C_BRACKET  shift, and go to state 151

    R_C_BRACKET  [reduce using rule 37 (elsify)]

    elsify  go to state 152
    elif    go to state 126
    else    go to state 127


State 142

   33 if: IF bool_exp L_C_BRACKET statements CONTINUE SEMICOLON . R_C_BRACKET
   34   | IF bool_exp L_C_BRACKET statements CONTINUE SEMICOLON . elsify R_C_BRACKET

    ELIF         shift, and go to state 120
    ELSE         shift, and go to state 121
    R_C_BRACKET  shift, and go to state 153

    R_C_BRACKET  [reduce using rule 37 (elsify)]

    elsify  go to state 154
    elif    go to state 126
    else    go to state 127


State 143

   30 if: IF bool_exp L_C_BRACKET statements elsify R_C_BRACKET .

    $default  reduce using rule 30 (if)


State 144

   35 elsify: elif elsify .

    $default  reduce using rule 35 (elsify)


State 145

   41 for: FOR num SEMICOLON bool_exp ID ASSIGN . exp L_C_BRACKET statements R_C_BRACKET

    NUMBER   shift, and go to state 39
    L_PAREN  shift, and go to state 40
    ID       shift, and go to state 59

    exp            go to state 155
    term           go to state 43
    factor         go to state 44
    function_call  go to state 45


State 146

   21 statement: ID L_BRACKET NUMBER R_BRACKET ASSIGN exp .
   46 exp: exp . PLUS term
   47    | exp . MINUS term

    PLUS   shift, and go to state 62
    MINUS  shift, and go to state 63

    $default  reduce using rule 21 (statement)


State 147

   43 input: INPUT L_PAREN ID L_BRACKET NUMBER R_BRACKET R_PAREN .

    $default  reduce using rule 43 (input)


State 148

   45 output: OUTPUT L_PAREN ID L_BRACKET NUMBER R_BRACKET R_PAREN .

    $default  reduce using rule 45 (output)


State 149

   38 elif: ELIF bool_exp L_C_BRACKET . statements R_C_BRACKET

    RETURN  shift, and go to state 19
    INPUT   shift, and go to state 20
    OUTPUT  shift, and go to state 21
    NUM     shift, and go to state 22
    WHILE   shift, and go to state 23
    IF      shift, and go to state 24
    FOR     shift, and go to state 25
    ID      shift, and go to state 26

    $default  reduce using rule 11 (statements)

    statements     go to state 156
    statement      go to state 28
    return         go to state 29
    num            go to state 30
    if             go to state 31
    while          go to state 32
    for            go to state 33
    input          go to state 34
    output         go to state 35
    declaration    go to state 36
    function_call  go to state 37


State 150

   39 else: ELSE L_C_BRACKET statements . R_C_BRACKET

    R_C_BRACKET  shift, and go to state 157


State 151

   31 if: IF bool_exp L_C_BRACKET statements BREAK SEMICOLON R_C_BRACKET .

    $default  reduce using rule 31 (if)


State 152

   32 if: IF bool_exp L_C_BRACKET statements BREAK SEMICOLON elsify . R_C_BRACKET

    R_C_BRACKET  shift, and go to state 158


State 153

   33 if: IF bool_exp L_C_BRACKET statements CONTINUE SEMICOLON R_C_BRACKET .

    $default  reduce using rule 33 (if)


State 154

   34 if: IF bool_exp L_C_BRACKET statements CONTINUE SEMICOLON elsify . R_C_BRACKET

    R_C_BRACKET  shift, and go to state 159


State 155

   41 for: FOR num SEMICOLON bool_exp ID ASSIGN exp . L_C_BRACKET statements R_C_BRACKET
   46 exp: exp . PLUS term
   47    | exp . MINUS term

    PLUS         shift, and go to state 62
    MINUS        shift, and go to state 63
    L_C_BRACKET  shift, and go to state 160


State 156

   38 elif: ELIF bool_exp L_C_BRACKET statements . R_C_BRACKET

    R_C_BRACKET  shift, and go to state 161


State 157

   39 else: ELSE L_C_BRACKET statements R_C_BRACKET .

    $default  reduce using rule 39 (else)


State 158

   32 if: IF bool_exp L_C_BRACKET statements BREAK SEMICOLON elsify R_C_BRACKET .

    $default  reduce using rule 32 (if)


State 159

   34 if: IF bool_exp L_C_BRACKET statements CONTINUE SEMICOLON elsify R_C_BRACKET .

    $default  reduce using rule 34 (if)


State 160

   41 for: FOR num SEMICOLON bool_exp ID ASSIGN exp L_C_BRACKET . statements R_C_BRACKET

    RETURN  shift, and go to state 19
    INPUT   shift, and go to state 20
    OUTPUT  shift, and go to state 21
    NUM     shift, and go to state 22
    WHILE   shift, and go to state 23
    IF      shift, and go to state 24
    FOR     shift, and go to state 25
    ID      shift, and go to state 26

    $default  reduce using rule 11 (statements)

    statements     go to state 162
    statement      go to state 28
    return         go to state 29
    num            go to state 30
    if             go to state 31
    while          go to state 32
    for            go to state 33
    input          go to state 34
    output         go to state 35
    declaration    go to state 36
    function_call  go to state 37


State 161

   38 elif: ELIF bool_exp L_C_BRACKET statements R_C_BRACKET .

    $default  reduce using rule 38 (elif)


State 162

   41 for: FOR num SEMICOLON bool_exp ID ASSIGN exp L_C_BRACKET statements . R_C_BRACKET

    R_C_BRACKET  shift, and go to state 163


State 163

   41 for: FOR num SEMICOLON bool_exp ID ASSIGN exp L_C_BRACKET statements R_C_BRACKET .

    $default  reduce using rule 41 (for)
