Nonterminals useless in grammar

   if
   while
   for
   bool_exp


Terminals unused in grammar

   RETURN
   WHILE
   IF
   ELIF
   ELSE
   LESS
   GREATER
   EQUAL
   NOT_EQUAL
   LE_EQ
   GE_EQ
   COMMENT
   L_BRACKET
   R_BRACKET
   FOR


Rules useless in grammar

   37 statement: if
   38          | while
   39          | for

   40 if: IF bool_exp L_C_BRACKET statements R_C_BRACKET

   41 while: WHILE bool_exp L_C_BRACKET statements R_C_BRACKET

   42 for: FOR num ASSIGN NUMBER SEMICOLON bool_exp SEMICOLON num ASSIGN exp L_C_BRACKET statements R_C_BRACKET

   43 bool_exp: bool_exp


Rules useless in parser due to conflicts

   36 args: %empty


State 8 conflicts: 1 reduce/reduce
State 14 conflicts: 1 reduce/reduce
State 31 conflicts: 1 reduce/reduce
State 45 conflicts: 3 reduce/reduce


Grammar

    0 $accept: prog_start $end

    1 prog_start: %empty
    2           | functions

    3 functions: function
    4          | function functions

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    6 args: arg COMMA args
    7     | arg

    8 arg: %empty
    9    | NUM ID

   10 statements: statement SEMICOLON
   11           | statement SEMICOLON statements

   12 statement: declaration
   13          | function_call
   14          | num
   15          | input
   16          | output

   17 num: NUM ID ASSIGN exp
   18    | NUM ID ASSIGN NUMBER
   19    | NUM ID ASSIGN function_call

   20 input: INPUT L_PAREN num_list R_PAREN

   21 output: OUTPUT L_PAREN num_list R_PAREN

   22 num_list: %empty
   23         | COMMA num num_list

   24 exp: exp add_op term
   25    | term

   26 add_op: PLUS
   27       | MINUS

   28 term: term mulop factor
   29     | factor

   30 mulop: MULTI
   31      | DIVISION

   32 factor: L_PAREN exp R_PAREN
   33       | NUMBER

   34 declaration: NUM ID

   35 function_call: ID L_PAREN args R_PAREN

   36 args: %empty


Terminals, with rules where they appear

$end (0) 0
error (256)
RETURN (258)
INPUT (259) 20
OUTPUT (260) 21
NUMBER (261) 18 33
NUM (262) 9 17 18 19 34
WHILE (263)
IF (264)
ELIF (265)
ELSE (266)
FUNC (267) 5
ID (268) 5 9 17 18 19 34 35
PLUS (269) 26
MINUS (270) 27
MULTI (271) 30
DIVISION (272) 31
LESS (273)
GREATER (274)
EQUAL (275)
NOT_EQUAL (276)
LE_EQ (277)
GE_EQ (278)
COMMENT (279)
L_BRACKET (280)
R_BRACKET (281)
L_C_BRACKET (282) 5
R_C_BRACKET (283) 5
L_PAREN (284) 5 20 21 32 35
R_PAREN (285) 5 20 21 32 35
ASSIGN (286) 17 18 19
SEMICOLON (287) 5 10 11
COMMA (288) 6 23
FOR (289)


Nonterminals, with rules where they appear

$accept (35)
    on left: 0
prog_start (36)
    on left: 1 2, on right: 0
functions (37)
    on left: 3 4, on right: 2 4
function (38)
    on left: 5, on right: 3 4
args (39)
    on left: 6 7 36, on right: 5 6 35
arg (40)
    on left: 8 9, on right: 6 7
statements (41)
    on left: 10 11, on right: 5 11
statement (42)
    on left: 12 13 14 15 16, on right: 10 11
num (43)
    on left: 17 18 19, on right: 14 23
input (44)
    on left: 20, on right: 15
output (45)
    on left: 21, on right: 16
num_list (46)
    on left: 22 23, on right: 20 21 23
exp (47)
    on left: 24 25, on right: 17 24 32
add_op (48)
    on left: 26 27, on right: 24
term (49)
    on left: 28 29, on right: 24 25 28
mulop (50)
    on left: 30 31, on right: 28
factor (51)
    on left: 32 33, on right: 28 29
declaration (52)
    on left: 34, on right: 12
function_call (53)
    on left: 35, on right: 13 19


State 0

    0 $accept: . prog_start $end

    FUNC  shift, and go to state 1

    $default  reduce using rule 1 (prog_start)

    prog_start  go to state 2
    functions   go to state 3
    function    go to state 4


State 1

    5 function: FUNC . ID L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    ID  shift, and go to state 5


State 2

    0 $accept: prog_start . $end

    $end  shift, and go to state 6


State 3

    2 prog_start: functions .

    $default  reduce using rule 2 (prog_start)


State 4

    3 functions: function .
    4          | function . functions

    FUNC  shift, and go to state 1

    $default  reduce using rule 3 (functions)

    functions  go to state 7
    function   go to state 4


State 5

    5 function: FUNC ID . L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    L_PAREN  shift, and go to state 8


State 6

    0 $accept: prog_start $end .

    $default  accept


State 7

    4 functions: function functions .

    $default  reduce using rule 4 (functions)


State 8

    5 function: FUNC ID L_PAREN . args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    NUM  shift, and go to state 9

    R_PAREN   reduce using rule 8 (arg)
    R_PAREN   [reduce using rule 36 (args)]
    $default  reduce using rule 8 (arg)

    args  go to state 10
    arg   go to state 11


State 9

    9 arg: NUM . ID

    ID  shift, and go to state 12


State 10

    5 function: FUNC ID L_PAREN args . R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON

    R_PAREN  shift, and go to state 13


State 11

    6 args: arg . COMMA args
    7     | arg .

    COMMA  shift, and go to state 14

    $default  reduce using rule 7 (args)


State 12

    9 arg: NUM ID .

    $default  reduce using rule 9 (arg)


State 13

    5 function: FUNC ID L_PAREN args R_PAREN . L_C_BRACKET statements R_C_BRACKET SEMICOLON

    L_C_BRACKET  shift, and go to state 15


State 14

    6 args: arg COMMA . args

    NUM  shift, and go to state 9

    R_PAREN   reduce using rule 8 (arg)
    R_PAREN   [reduce using rule 36 (args)]
    $default  reduce using rule 8 (arg)

    args  go to state 16
    arg   go to state 11


State 15

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET . statements R_C_BRACKET SEMICOLON

    INPUT   shift, and go to state 17
    OUTPUT  shift, and go to state 18
    NUM     shift, and go to state 19
    ID      shift, and go to state 20

    statements     go to state 21
    statement      go to state 22
    num            go to state 23
    input          go to state 24
    output         go to state 25
    declaration    go to state 26
    function_call  go to state 27


State 16

    6 args: arg COMMA args .

    $default  reduce using rule 6 (args)


State 17

   20 input: INPUT . L_PAREN num_list R_PAREN

    L_PAREN  shift, and go to state 28


State 18

   21 output: OUTPUT . L_PAREN num_list R_PAREN

    L_PAREN  shift, and go to state 29


State 19

   17 num: NUM . ID ASSIGN exp
   18    | NUM . ID ASSIGN NUMBER
   19    | NUM . ID ASSIGN function_call
   34 declaration: NUM . ID

    ID  shift, and go to state 30


State 20

   35 function_call: ID . L_PAREN args R_PAREN

    L_PAREN  shift, and go to state 31


State 21

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET statements . R_C_BRACKET SEMICOLON

    R_C_BRACKET  shift, and go to state 32


State 22

   10 statements: statement . SEMICOLON
   11           | statement . SEMICOLON statements

    SEMICOLON  shift, and go to state 33


State 23

   14 statement: num .

    $default  reduce using rule 14 (statement)


State 24

   15 statement: input .

    $default  reduce using rule 15 (statement)


State 25

   16 statement: output .

    $default  reduce using rule 16 (statement)


State 26

   12 statement: declaration .

    $default  reduce using rule 12 (statement)


State 27

   13 statement: function_call .

    $default  reduce using rule 13 (statement)


State 28

   20 input: INPUT L_PAREN . num_list R_PAREN

    COMMA  shift, and go to state 34

    $default  reduce using rule 22 (num_list)

    num_list  go to state 35


State 29

   21 output: OUTPUT L_PAREN . num_list R_PAREN

    COMMA  shift, and go to state 34

    $default  reduce using rule 22 (num_list)

    num_list  go to state 36


State 30

   17 num: NUM ID . ASSIGN exp
   18    | NUM ID . ASSIGN NUMBER
   19    | NUM ID . ASSIGN function_call
   34 declaration: NUM ID .

    ASSIGN  shift, and go to state 37

    $default  reduce using rule 34 (declaration)


State 31

   35 function_call: ID L_PAREN . args R_PAREN

    NUM  shift, and go to state 9

    R_PAREN   reduce using rule 8 (arg)
    R_PAREN   [reduce using rule 36 (args)]
    $default  reduce using rule 8 (arg)

    args  go to state 38
    arg   go to state 11


State 32

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET . SEMICOLON

    SEMICOLON  shift, and go to state 39


State 33

   10 statements: statement SEMICOLON .
   11           | statement SEMICOLON . statements

    INPUT   shift, and go to state 17
    OUTPUT  shift, and go to state 18
    NUM     shift, and go to state 19
    ID      shift, and go to state 20

    $default  reduce using rule 10 (statements)

    statements     go to state 40
    statement      go to state 22
    num            go to state 23
    input          go to state 24
    output         go to state 25
    declaration    go to state 26
    function_call  go to state 27


State 34

   23 num_list: COMMA . num num_list

    NUM  shift, and go to state 41

    num  go to state 42


State 35

   20 input: INPUT L_PAREN num_list . R_PAREN

    R_PAREN  shift, and go to state 43


State 36

   21 output: OUTPUT L_PAREN num_list . R_PAREN

    R_PAREN  shift, and go to state 44


State 37

   17 num: NUM ID ASSIGN . exp
   18    | NUM ID ASSIGN . NUMBER
   19    | NUM ID ASSIGN . function_call

    NUMBER   shift, and go to state 45
    ID       shift, and go to state 20
    L_PAREN  shift, and go to state 46

    exp            go to state 47
    term           go to state 48
    factor         go to state 49
    function_call  go to state 50


State 38

   35 function_call: ID L_PAREN args . R_PAREN

    R_PAREN  shift, and go to state 51


State 39

    5 function: FUNC ID L_PAREN args R_PAREN L_C_BRACKET statements R_C_BRACKET SEMICOLON .

    $default  reduce using rule 5 (function)


State 40

   11 statements: statement SEMICOLON statements .

    $default  reduce using rule 11 (statements)


State 41

   17 num: NUM . ID ASSIGN exp
   18    | NUM . ID ASSIGN NUMBER
   19    | NUM . ID ASSIGN function_call

    ID  shift, and go to state 52


State 42

   23 num_list: COMMA num . num_list

    COMMA  shift, and go to state 34

    $default  reduce using rule 22 (num_list)

    num_list  go to state 53


State 43

   20 input: INPUT L_PAREN num_list R_PAREN .

    $default  reduce using rule 20 (input)


State 44

   21 output: OUTPUT L_PAREN num_list R_PAREN .

    $default  reduce using rule 21 (output)


State 45

   18 num: NUM ID ASSIGN NUMBER .
   33 factor: NUMBER .

    R_PAREN    reduce using rule 18 (num)
    R_PAREN    [reduce using rule 33 (factor)]
    SEMICOLON  reduce using rule 18 (num)
    SEMICOLON  [reduce using rule 33 (factor)]
    COMMA      reduce using rule 18 (num)
    COMMA      [reduce using rule 33 (factor)]
    $default   reduce using rule 33 (factor)


State 46

   32 factor: L_PAREN . exp R_PAREN

    NUMBER   shift, and go to state 54
    L_PAREN  shift, and go to state 46

    exp     go to state 55
    term    go to state 48
    factor  go to state 49


State 47

   17 num: NUM ID ASSIGN exp .
   24 exp: exp . add_op term

    PLUS   shift, and go to state 56
    MINUS  shift, and go to state 57

    $default  reduce using rule 17 (num)

    add_op  go to state 58


State 48

   25 exp: term .
   28 term: term . mulop factor

    MULTI     shift, and go to state 59
    DIVISION  shift, and go to state 60

    $default  reduce using rule 25 (exp)

    mulop  go to state 61


State 49

   29 term: factor .

    $default  reduce using rule 29 (term)


State 50

   19 num: NUM ID ASSIGN function_call .

    $default  reduce using rule 19 (num)


State 51

   35 function_call: ID L_PAREN args R_PAREN .

    $default  reduce using rule 35 (function_call)


State 52

   17 num: NUM ID . ASSIGN exp
   18    | NUM ID . ASSIGN NUMBER
   19    | NUM ID . ASSIGN function_call

    ASSIGN  shift, and go to state 37


State 53

   23 num_list: COMMA num num_list .

    $default  reduce using rule 23 (num_list)


State 54

   33 factor: NUMBER .

    $default  reduce using rule 33 (factor)


State 55

   24 exp: exp . add_op term
   32 factor: L_PAREN exp . R_PAREN

    PLUS     shift, and go to state 56
    MINUS    shift, and go to state 57
    R_PAREN  shift, and go to state 62

    add_op  go to state 58


State 56

   26 add_op: PLUS .

    $default  reduce using rule 26 (add_op)


State 57

   27 add_op: MINUS .

    $default  reduce using rule 27 (add_op)


State 58

   24 exp: exp add_op . term

    NUMBER   shift, and go to state 54
    L_PAREN  shift, and go to state 46

    term    go to state 63
    factor  go to state 49


State 59

   30 mulop: MULTI .

    $default  reduce using rule 30 (mulop)


State 60

   31 mulop: DIVISION .

    $default  reduce using rule 31 (mulop)


State 61

   28 term: term mulop . factor

    NUMBER   shift, and go to state 54
    L_PAREN  shift, and go to state 46

    factor  go to state 64


State 62

   32 factor: L_PAREN exp R_PAREN .

    $default  reduce using rule 32 (factor)


State 63

   24 exp: exp add_op term .
   28 term: term . mulop factor

    MULTI     shift, and go to state 59
    DIVISION  shift, and go to state 60

    $default  reduce using rule 24 (exp)

    mulop  go to state 61


State 64

   28 term: term mulop factor .

    $default  reduce using rule 28 (term)
